#!/bin/bash

# ==============================================================================
# Socat Configuration Manager
#
# Reads socat.conf and synchronizes the running socat listeners to match
# the configuration exactly. Automatically generates config suggestions
# when stale/duplicate processes are detected.
# ==============================================================================

# --- Script Information and Configuration ---

# Versioning: Please follow Semantic Versioning (MAJOR.MINOR.PATCH)
VERSION="0.4.0 (2025-09-11)" # <-- INCREMENT ME ON MODIFICATION

SCRIPT_NAME=$(basename "$0")
CONFIG_FILE="$HOME/socat.conf"


# --- Help Message Function ---
usage() {
    cat << EOF
Socat Configuration Manager - v$VERSION

Reads socat.conf and synchronizes the running socat listeners to match
the configuration exactly. It is safe to run periodically from cron.

Usage: $SCRIPT_NAME [OPTION]

DEFAULT BEHAVIOR:
  If run with no option, the script performs a simulation (dry run),
  showing what changes would be made without actually executing them.
  If stale/duplicate processes are found, suggested config lines are
  automatically generated and saved to a temporary file.

OPTIONS:
  --apply          Apply the configuration. Kills stale/duplicate listeners
                   and starts any missing listeners.
  -h, --help       Display this help message and exit.
  -v, --version    Display the script version and exit.
EOF
}

# --- Function to generate config for stale processes ---
generate_config_for_stale_processes() {
    local stale_commands=("$@")

    if [ ${#stale_commands[@]} -eq 0 ]; then
        return
    fi

    # Parse and generate config lines (using associative array to auto-deduplicate)
    declare -A ip_configs
    declare -A seen_commands

    for cmd in "${stale_commands[@]}"; do
        # Skip if we've already seen this command
        if [ "${seen_commands[$cmd]}" = "1" ]; then
            continue
        fi
        seen_commands[$cmd]=1
        # Extract local_port and remote_ip:remote_port from command
        # Example: socat TCP-LISTEN:6220,fork TCP:10.10.55.70:6022
        if [[ "$cmd" =~ socat\ TCP-LISTEN:([0-9]+),fork\ TCP:([0-9.]+):([0-9]+) ]]; then
            local_port="${BASH_REMATCH[1]}"
            remote_ip="${BASH_REMATCH[2]}"
            remote_port="${BASH_REMATCH[3]}"

            # Determine service label based on common port patterns
            label="port${local_port}"
            case "$remote_port" in
                22) label="ssh" ;;
                80) label="http" ;;
                443) label="https" ;;
                6022) label="node" ;;
                5022) label="logstash" ;;
                10051) label="zabbix" ;;
            esac

            # Group by remote IP
            triplet="${label}:${local_port}:${remote_port}"
            if [ -n "${ip_configs[$remote_ip]}" ]; then
                ip_configs[$remote_ip]+="  $triplet"
            else
                ip_configs[$remote_ip]="$triplet"
            fi
        fi
    done

    echo
    echo "# --- ATTN: Possible Config Changes --- $CONFIG_FILE"
    for remote_ip in $(printf '%s\n' "${!ip_configs[@]}" | sort -V); do
        echo
        echo "# ATTN"
        echo "$remote_ip  ${ip_configs[$remote_ip]}"
    done
}

# --- Main Logic Function ---
main() {
    # --- Temporary Files ---
    # Using mktemp for security and to avoid collisions.
    DESIRED_STATE_FILE=$(mktemp)
    PIDS_TO_KEEP_FILE=$(mktemp)
    RUNNING_PIDS_FILE=$(mktemp)

    # Ensure ALL temporary files are cleaned up when the script exits.
    trap 'rm -f "$DESIRED_STATE_FILE" "$PIDS_TO_KEEP_FILE" "$RUNNING_PIDS_FILE"' EXIT

    # --- Mode Detection ---
    DRY_RUN=1 # Default to dry run (1 = true)
    EXECUTE_MSG_PREFIX="[DRY RUN] "

    if [ "$ACTION" == "apply" ]; then
        DRY_RUN=0 # Set to apply mode (0 = false)
        EXECUTE_MSG_PREFIX=""
        echo "--- RUNNING IN APPLY MODE ---"
    else
        echo "--- RUNNING IN SIMULATION (DRY RUN) MODE ---"
        echo "No changes will be made. To apply changes, run again with the '--apply' parameter."
    fi

    # --- Main Execution ---
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "ERROR: Configuration file not found at $CONFIG_FILE" >&2
        exit 1
    fi

    echo
    echo "--- Step 1: Reading configuration and generating desired state ---"

    while IFS= read -r line; do
        [[ -z "$line" || "$line" =~ ^\s*# ]] && continue
        read -r -a parts <<< "$line"
        remote_ip="${parts[0]}"
        for (( i=1; i<${#parts[@]}; i++ )); do
            triplet="${parts[$i]}"
            local_port=$(echo "$triplet" | awk -F':' '{print $2}')
            remote_port=$(echo "$triplet" | awk -F':' '{print $3}')
            command="socat TCP-LISTEN:${local_port},fork TCP:${remote_ip}:${remote_port}"
            echo "$command" >> "$DESIRED_STATE_FILE"
        done
    done < "$CONFIG_FILE"
    echo "Found $(wc -l < "$DESIRED_STATE_FILE") desired socat processes in config."

    echo
    echo "--- Step 2: Identifying PIDs of parent listeners to keep ---"

    # Keep track of commands and their parent PIDs to detect duplicates
    declare -A cmd_to_parent_pids
    declare -A pids_to_keep

    while IFS= read -r desired_cmd; do
        # Find all PIDs running this exact command
        mapfile -t matching_pids < <(pgrep -fx "$desired_cmd")

        # Filter to only parent processes (not forked children)
        #
        # Parent-child detection logic:
        # 1. Parent process: PPID=1 (init) OR parent doesn't run same socat command
        # 2. Child process: PPID=another_socat_pid AND parent runs identical command
        #
        # Example from real system:
        # 3456898  1     socat TCP-LISTEN:6220,fork TCP:10.10.55.70:6022  ← PARENT (PPID=1)
        # 3457089  3456898 socat TCP-LISTEN:6220,fork TCP:10.10.55.70:6022  ← CHILD (PPID=parent, same cmd)
        # 3457207  3456898 socat TCP-LISTEN:6220,fork TCP:10.10.55.70:6022  ← CHILD (PPID=parent, same cmd)
        parent_pids=()
        for pid in "${matching_pids[@]}"; do
            # Check if this process has a parent that also runs the same command
            ppid=$(ps -o ppid= -p "$pid" 2>/dev/null | tr -d '[:space:]')
            if [ -n "$ppid" ] && [ "$ppid" != "1" ]; then
                # Check if parent runs the same socat command
                if [ -r "/proc/$ppid/cmdline" ]; then
                    parent_cmd=$(tr '\0' ' ' < "/proc/$ppid/cmdline" 2>/dev/null | sed 's/ $//' || echo "")
                    if [ "$parent_cmd" = "$desired_cmd" ]; then
                        # This is a child process (parent runs same command), skip it
                        continue
                    fi
                fi
            fi
            # This is a parent process (PPID=1 or parent runs different command)
            parent_pids+=("$pid")
        done

        if [ ${#parent_pids[@]} -gt 0 ]; then
            # Keep only the oldest (first) parent PID for this command
            oldest_parent="${parent_pids[0]}"
            pids_to_keep["$oldest_parent"]=1
            echo "$oldest_parent" >> "$PIDS_TO_KEEP_FILE"

            # Track all parent PIDs for this command for duplicate detection
            cmd_to_parent_pids["$desired_cmd"]="${parent_pids[*]}"
        fi
    done < "$DESIRED_STATE_FILE"

    echo "Found $(wc -l < "$PIDS_TO_KEEP_FILE") existing parent listeners that match the config."

    # Report duplicates
    FOUND_DUPLICATES=0
    for cmd in "${!cmd_to_parent_pids[@]}"; do
        read -ra pids <<< "${cmd_to_parent_pids[$cmd]}"
        if [ ${#pids[@]} -gt 1 ]; then
            FOUND_DUPLICATES=1
            echo "Found ${#pids[@]} duplicate parent instances of: $cmd"
            for ((i=1; i<${#pids[@]}; i++)); do
                echo "  Duplicate parent PID: ${pids[$i]}"
            done
        fi
    done

    if [ $FOUND_DUPLICATES -eq 0 ]; then
        echo "No duplicate parent processes found."
    fi

    echo
    echo "--- Step 3: Checking for unknown listeners and their children ---"

    HAS_STALE_PROCESSES=0
    declare -a stale_commands=()
    declare -A unknown_parents
    declare -A unknown_children

    # Get all running PIDs into our temporary file first.
    pidof socat | tr ' ' '\n' > "$RUNNING_PIDS_FILE"

    # First pass: identify unknown processes and their relationships
    while IFS= read -r pid; do
        if ! grep -xq "$pid" "$PIDS_TO_KEEP_FILE"; then
            ppid=$(ps -o ppid= -p "$pid" 2>/dev/null | tr -d '[:space:]')

            if grep -xq "$ppid" "$PIDS_TO_KEEP_FILE"; then
                # This is a legitimate child worker of a configured parent, ignore it
                continue
            else
                HAS_STALE_PROCESSES=1
                running_cmd=$(tr '\0' ' ' < "/proc/$pid/cmdline" 2>/dev/null | sed 's/ $//')

                # Determine if this is a child of an unknown parent or an unknown parent itself
                if [ -n "$ppid" ] && [ "$ppid" != "1" ] && [ -r "/proc/$ppid/cmdline" ]; then
                    parent_cmd=$(tr '\0' ' ' < "/proc/$ppid/cmdline" 2>/dev/null | sed 's/ $//' || echo "")
                    if [ "$parent_cmd" = "$running_cmd" ]; then
                        # This is a child of an unknown parent
                        unknown_children["$pid"]="$ppid"
                    else
                        # This is an unknown parent
                        unknown_parents["$pid"]="$running_cmd"
                    fi
                else
                    # This is an unknown parent (PPID=1 or can't read parent)
                    unknown_parents["$pid"]="$running_cmd"
                fi

                # Only save TCP-LISTEN commands for config generation
                if [[ "$running_cmd" == socat\ TCP-LISTEN:* ]]; then
                    stale_commands+=("$running_cmd")
                fi
            fi
        fi
    done < "$RUNNING_PIDS_FILE"

    # Display results in tree format
    if [ $HAS_STALE_PROCESSES -eq 1 ]; then
        for parent_pid in "${!unknown_parents[@]}"; do
            parent_cmd="${unknown_parents[$parent_pid]}"
            echo "${EXECUTE_MSG_PREFIX}Would kill unknown parent (PID: $parent_pid): $parent_cmd"

            # Show children of this parent
            for child_pid in "${!unknown_children[@]}"; do
                child_ppid="${unknown_children[$child_pid]}"
                if [ "$child_ppid" = "$parent_pid" ]; then
                    echo "${EXECUTE_MSG_PREFIX}  └── Would kill child (PID: $child_pid)"
                fi
            done

            if [ "$DRY_RUN" -eq 0 ]; then
                kill "$parent_pid"
                # Kill children too
                for child_pid in "${!unknown_children[@]}"; do
                    child_ppid="${unknown_children[$child_pid]}"
                    if [ "$child_ppid" = "$parent_pid" ]; then
                        kill "$child_pid"
                    fi
                done
            fi
        done
    fi

    if [ "$HAS_STALE_PROCESSES" -eq 0 ]; then
        echo "No stale or duplicate listeners found."
    fi

    echo
    echo "--- Step 4: Checking for missing parent listeners to be started ---"

    HAS_MISSING_PROCESSES=0
    while IFS= read -r desired_cmd; do
        if ! pgrep -fx "$desired_cmd" > /dev/null; then
            HAS_MISSING_PROCESSES=1
            echo "${EXECUTE_MSG_PREFIX}Would start missing listener: $desired_cmd"
            if [ "$DRY_RUN" -eq 0 ]; then
                eval "$desired_cmd &"
            fi
        fi
    done < "$DESIRED_STATE_FILE"
    if [ "$HAS_MISSING_PROCESSES" -eq 0 ]; then
        echo "No missing listeners found."
    fi

    echo
    echo "--- Socat state synchronization complete. ---"

    # Generate config suggestions if stale processes were found
    if [ "$HAS_STALE_PROCESSES" -eq 1 ]; then
        generate_config_for_stale_processes "${stale_commands[@]}"
    fi
}


# --- Argument Parsing ---
# Default action is to perform a dry run.
ACTION="dry-run"

# Handle case of more than one argument
if [ $# -gt 1 ]; then
    echo "Error: Only one option is allowed." >&2
    usage
    exit 1
fi

# Handle the single argument, if provided
if [ $# -eq 1 ]; then
    case "$1" in
        --apply)
            ACTION="apply"
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        -v|--version)
            echo "$SCRIPT_NAME version $VERSION"
            exit 0
            ;;
        *)
            echo "Error: Unknown option '$1'" >&2
            echo
            usage
            exit 1
            ;;
    esac
fi

# --- Run the main script logic ---
main

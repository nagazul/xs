#!/bin/bash
# xrun: Advanced SSH Host Runner & Command/Script Executor

# Strict mode
set -euo pipefail

# --- Color Definitions ---
CN='\033[0m'    # Reset/None
CG='\033[0;32m' # Green
CR='\033[0;31m' # Red
CB='\033[0;34m' # Blue (hostnames)
CY='\033[0;33m' # Yellow (warnings, PIDs, timing)
CM='\033[0;35m' # Magenta (progress)
CC='\033[0;36m' # Cyan (info)

# --- Configuration & Internal Variables ---
SSH_CFG="$HOME/.ssh/config"
SSH_TIMEOUT=10 # Seconds for SSH connection timeout

XRUN_EXEC_STRAT="controlled_parallel" # Primary execution mode

# Max concurrent jobs
_cpu_cores=$(nproc 2>/dev/null || echo 1) # Get core count, default to 1 if nproc fails
_max_jobs_cap=10
_calc_max_jobs=$(( _cpu_cores * 3 ))

if [[ "$_calc_max_jobs" -lt "$_max_jobs_cap" ]]; then
    MAX_JOBS="$_calc_max_jobs"
else
    MAX_JOBS="$_max_jobs_cap"
fi
# For testing:
# MAX_JOBS=2

XRUN_SSH_TTY_OPT="-T" # Default: no TTY
# XRUN_SSH_TTY_OPT="-tt" # For TTY testing

SSH_OPTS_BASE=(
    -o "ConnectTimeout=${SSH_TIMEOUT}"
    -o "BatchMode=yes"
    -o "PasswordAuthentication=no"
    -o "StrictHostKeyChecking=no"
)

TMP_BASE="${TMPDIR:-/tmp}"
SESS_DIR_ROOT="${TMP_BASE}/xrun_sessions_${USER:-$(id -u)}"
SESS_TMP_DIR="" # Set per session

# --- Utility Functions ---
_dbg() {
    if [[ "${XRUN_DEBUG:-0}" == "1" ]]; then
        echo -e "${CY}DBG: $1${CN}" >&2
    fi
}

print_usage() {
    local scr_name
    scr_name=$(basename "$0")
    echo "Usage: $scr_name [--sudo|-s] <host_specs> [remote_command_and_args...]" >&2
    echo "   or: cat ./script.sh | $scr_name [--sudo|-s] <host_specs>" >&2
    echo "   or: $scr_name [--sudo|-s] <host_specs> < ./script.sh" >&2
    echo "   or: $scr_name <host_specs> # List matching hosts" >&2
    echo "   or: $scr_name              # List all hosts from $SSH_CFG" >&2
    echo "" >&2
    echo "Options:" >&2
    echo "  --sudo, -s        - Prepend 'sudo' to the remote command/script." >&2
    echo "" >&2
    echo "<host_specs> examples:" >&2
    echo "  'h1,h2'           - Specific hosts" >&2
    echo "  'user@h1'         - User on host" >&2
    echo "  '@[prod:web]'     - Hosts matching 'prod' AND 'web' (from $SSH_CFG)" >&2
    echo "  '@[dev,-test]'    - Match 'dev' NOT 'test'" >&2
    echo "  'user@@[p,s]'   - 'user' on hosts matching 'p' OR 's'" >&2
    echo "  '@[*]' or (none) - All hosts from $SSH_CFG" >&2
    echo "" >&2
    echo "Commands/scripts run as the remote login user by default." >&2
    echo "Use '--sudo' or '-s' to execute with 'sudo' on remote hosts." >&2
    echo "Parallel exec (Max jobs: $MAX_JOBS)." >&2
    echo "Set XRUN_DEBUG=1 for verbose debug." >&2
}

is_bash43_plus() {
    if [[ -z "${BASH_VERSION:-}" ]]; then return 1; fi
    local major="${BASH_VERSION%%.*}"
    local minor_patch="${BASH_VERSION#*.}"
    local minor="${minor_patch%%.*}"
    if ! ( [[ "$major" -gt 4 ]] || ([[ "$major" -eq 4 && "$minor" -ge 3 ]]) ); then
        return 1
    fi
    local _dummy_pid=""
    ( sleep 0.01 & wait -n -p _dummy_pid 2>/dev/null )
    local wait_p_stat=$?
    if [[ "$wait_p_stat" -eq 0 && -n "$_dummy_pid" ]]; then
        return 0
    else
        return 1
    fi
}

get_all_hosts_cfg() {
    if [ ! -f "$SSH_CFG" ]; then
        return 1
    fi
    grep -i "^Host " "$SSH_CFG" | awk '{print $2}' | grep -Ev '[*?]' | sort -u
}

ALL_HOSTS_CACHE=""

match_pat() {
    local str="$1"
    local pat="$2"
    shopt -s nocasematch
    local res=1
    [[ "$str" == *"$pat"* ]] && res=0
    shopt -u nocasematch
    return $res
}

proc_filter() {
    local in_hosts="$1" # Can be empty, then ALL_HOSTS_CACHE is used
    local filter_str="$2"
    local list_only_mode="${3:-}" # "list_hosts" or ""

    if [[ -z "$ALL_HOSTS_CACHE" ]]; then
        local get_hosts_ret=0
        ALL_HOSTS_CACHE=$(get_all_hosts_cfg) || get_hosts_ret=$?

        if [[ "$get_hosts_ret" -ne 0 && "$list_only_mode" != "list_hosts" ]]; then
            echo -e "${CR}Err: SSH cfg '$SSH_CFG' not found.${CN}" >&2
            return 1
        elif [[ -z "$ALL_HOSTS_CACHE" && "$list_only_mode" != "list_hosts" ]]; then
            echo -e "${CY}Warn: No host defs in $SSH_CFG to filter.${CN}" >&2
        fi
    fi

    local eff_host_list="$in_hosts"
    if [[ -z "$in_hosts" && ("$filter_str" == "*" || -z "$filter_str") ]]; then
        eff_host_list="$ALL_HOSTS_CACHE"
    fi

    if [[ -z "$filter_str" || "$filter_str" == "*" ]]; then
        echo "$eff_host_list"
        return
    fi

    local base_list="$in_hosts"
    if [[ -z "$base_list" ]]; then
        base_list="$ALL_HOSTS_CACHE"
    fi

    if [[ "$filter_str" =~ : ]]; then # AND logic for colon-separated
        IFS=':' read -ra f_parts <<< "$filter_str"
        local curr_hosts="$base_list"

        for fp in "${f_parts[@]}"; do
            fp=$(echo "$fp" | xargs) # trim whitespace
            [[ -z "$curr_hosts" && -n "$fp" ]] && break
            local tmp_res=""
            if [[ "$fp" =~ ^- ]]; then # Exclusion
                local pat_excl="${fp:1}"
                if [[ -n "$pat_excl" ]]; then
                    while IFS= read -r h; do
                        [[ -n "$h" ]] || continue
                        if ! match_pat "$h" "$pat_excl"; then
                            tmp_res="${tmp_res}${h}"$'\n'
                        fi
                    done <<< "$curr_hosts"
                else
                    tmp_res="$curr_hosts"$'\n' # Empty exclusion does nothing
                fi
            else # Inclusion
                if [[ -n "$fp" ]]; then
                    while IFS= read -r h; do
                        [[ -n "$h" ]] || continue
                        if match_pat "$h" "$fp"; then
                            tmp_res="${tmp_res}${h}"$'\n'
                        fi
                    done <<< "$curr_hosts"
                else
                     tmp_res="$curr_hosts"$'\n' # Empty inclusion keeps current list
                fi
            fi
            curr_hosts="${tmp_res%$'\n'}"
        done
        [[ -n "$curr_hosts" ]] && echo "$curr_hosts"
    else # OR logic for comma-separated (with AND for exclusions)
        IFS=',' read -ra f_parts <<< "$filter_str"
        local incl_pats=()
        local excl_pats=()
        for fp in "${f_parts[@]}"; do
            fp=$(echo "$fp" | xargs)
            [[ -z "$fp" ]] && continue
            if [[ "$fp" =~ ^- ]]; then
                excl_pats+=("${fp:1}")
            else
                incl_pats+=("$fp")
            fi
        done

        local or_match_hosts=""
        if [[ ${#incl_pats[@]} -gt 0 ]]; then
            while IFS= read -r h; do
                [[ -n "$h" ]] || continue
                for pat_incl in "${incl_pats[@]}"; do
                    if match_pat "$h" "$pat_incl"; then
                        or_match_hosts="${or_match_hosts}${h}"$'\n'
                        break
                    fi
                done
            done <<< "$base_list"
            or_match_hosts="${or_match_hosts%$'\n'}"
        else # No include patterns, so base_list is starting point before exclusion
            or_match_hosts="$base_list"
        fi

        if [[ ${#excl_pats[@]} -gt 0 && -n "$or_match_hosts" ]]; then
            local final_hosts=""
            while IFS= read -r h; do
                [[ -n "$h" ]] || continue
                local do_excl=false
                for pat_excl in "${excl_pats[@]}"; do
                    if [[ -n "$pat_excl" ]] && match_pat "$h" "$pat_excl"; then
                        do_excl=true
                        break
                    fi
                done
                [[ "$do_excl" == false ]] && final_hosts="${final_hosts}${h}"$'\n'
            done <<< "$or_match_hosts"
            or_match_hosts="${final_hosts%$'\n'}"
        fi
        [[ -n "$or_match_hosts" ]] && echo "$or_match_hosts"
    fi
}

parse_specs() {
    local in_specs="$1"
    local list_mode="${2:-}" # "list_hosts" for context in proc_filter

    if [[ -z "$in_specs" ]]; then
        in_specs="@[*]" # Default to all hosts if no spec given
    fi

    local parts=()
    local curr_part=""
    local bracket_lvl=0
    for (( i=0; i<${#in_specs}; i++ )); do
        local char="${in_specs:$i:1}"
        case "$char" in
            "[") bracket_lvl=$((bracket_lvl + 1)) ;;
            "]") bracket_lvl=$((bracket_lvl - 1)) ;;
            ",")
                if [[ $bracket_lvl -eq 0 ]]; then
                    [[ -n "$curr_part" ]] && parts+=("$(echo "$curr_part" | xargs)")
                    curr_part=""
                    continue
                fi ;;
        esac
        curr_part+="$char"
    done
    [[ -n "$curr_part" ]] && parts+=("$(echo "$curr_part" | xargs)")

    local resolved_all=()
    for part in "${parts[@]}"; do
        if [[ "$part" =~ ^@\[([^\]]*)\]$ ]]; then # e.g., @[filter]
            local filter_str="${BASH_REMATCH[1]}"
            local filt_out
            filt_out=$(proc_filter "" "$filter_str" "$list_mode")
            while IFS= read -r h; do
                [[ -n "$h" ]] && resolved_all+=("$h")
            done <<< "$filt_out"
        elif [[ "$part" =~ ^([^@]+)@@\[([^\]]*)\]$ ]]; then # e.g., user@@[filter]
            local usr="${BASH_REMATCH[1]}"
            local filter_str="${BASH_REMATCH[2]}"
            local filt_out
            filt_out=$(proc_filter "" "$filter_str" "$list_mode")
            while IFS= read -r h; do
                [[ -n "$h" ]] && resolved_all+=("${usr}@${h}")
            done <<< "$filt_out"
        else # Direct host or user@host
            [[ -n "$part" ]] && resolved_all+=("$part")
        fi
    done

    if [[ ${#resolved_all[@]} -gt 0 ]]; then
        printf '%s\n' "${resolved_all[@]}" | sort -u
    fi
}

_run_task_remote() {
    local target_ssh="$1"
    local ex_mode="$2" # "cmd" or "pipe_script"
    local task_str="$3"
    local out_f="$4"
    local err_f="$5"
    local sudo_prefix="${6:-}" # Optional sudo prefix ("sudo " or "")
    local ret_code=0
    local ssh_arr=("ssh" "${SSH_OPTS_BASE[@]}" "$XRUN_SSH_TTY_OPT" "$target_ssh")

    trap '' INT TERM EXIT # Child inherits trap, clear for child

    set +e # Allow capturing exit status
    if [ "$ex_mode" = "cmd" ]; then
        "${ssh_arr[@]}" "${sudo_prefix}${task_str}" > "$out_f" 2> "$err_f"
        ret_code=$?
    elif [ "$ex_mode" = "pipe_script" ]; then
        echo "$task_str" | "${ssh_arr[@]}" "${sudo_prefix}bash -s" > "$out_f" 2> "$err_f"
        ret_code=$?
    else
        echo "Internal Err: Unknown ex_mode '$ex_mode' in _run_task_remote for $target_ssh" > "$err_f"
        ret_code=254
    fi
    return "$ret_code"
}

exec_parallel() {
    local -n targets_ref="$1" # Nameref to array of targets
    local ex_mode="$2"
    local task_str="$3"
    local sudo_prefix="${4:-}" # Optional sudo prefix
    local num_total=${#targets_ref[@]}

    _dbg "exec_parallel: Total hosts: $num_total, Max jobs: $MAX_JOBS, Sudo: '${sudo_prefix}'"
    echo -e "${CC}Parallel run on $num_total host(s) (Max jobs: $MAX_JOBS)...${CN}"

    declare -A pid_host_map pid_out_map pid_err_map pid_start_map pid_slot_map
    declare -a slot_pids=() # Stores PID for each slot, or empty if free
    for (( i=0; i<$MAX_JOBS; i++ )); do slot_pids[$i]=""; done

    local active_jobs=0
    local done_jobs=0
    local ok_cnt=0
    local fail_cnt=0
    local queue=("${targets_ref[@]}")

    while [ "$done_jobs" -lt "$num_total" ]; do
        _dbg "Loop top. Done: $done_jobs/$num_total. Active: $active_jobs. Queue: ${#queue[@]}. PIDs: ${!pid_host_map[*]}"

        # Launch new jobs
        while [ "$active_jobs" -lt "$MAX_JOBS" ] && [ "${#queue[@]}" -gt 0 ]; do
            local slot_idx=-1
            local slot_num_disp=0 # 1-based for display
            for (( i=0; i<$MAX_JOBS; i++ )); do
                if [[ -z "${slot_pids[$i]:-}" ]]; then
                    slot_idx=$i
                    slot_num_disp=$((i + 1))
                    break
                fi
            done

            if [[ "$slot_idx" -eq -1 ]]; then
                _dbg "No free slot found (active_jobs=$active_jobs vs MAX_JOBS=$MAX_JOBS). Breaking launch."
                break
            fi

            local target="${queue[0]}"
            queue=("${queue[@]:1}")
            local safe_name="${target//[^a-zA-Z0-9._-]/_}"
            local curr_out_f; curr_out_f=$(mktemp "${SESS_TMP_DIR}/${safe_name}.out.XXXXXX")
            local curr_err_f; curr_err_f=$(mktemp "${SESS_TMP_DIR}/${safe_name}.err.XXXXXX")

            _dbg "Launch: $target. Slot $slot_num_disp. Queue: ${#queue[@]}"
            echo -e "${CM}Run: ${CB}$target${CN} (Slot ${slot_num_disp}/${MAX_JOBS}, Q: ${#queue[@]})...${CN}"

            local launch_t; launch_t=$(date +%s)
            ( _run_task_remote "$target" "$ex_mode" "$task_str" "$curr_out_f" "$curr_err_f" "$sudo_prefix" ) &
            local bg_pid=$!

            pid_host_map["$bg_pid"]="$target"
            pid_out_map["$bg_pid"]="$curr_out_f"
            pid_err_map["$bg_pid"]="$curr_err_f"
            pid_start_map["$bg_pid"]="$launch_t"
            pid_slot_map["$bg_pid"]="$slot_num_disp"
            slot_pids[$slot_idx]="$bg_pid"

            active_jobs=$((active_jobs + 1))
            _dbg "Launched PID $bg_pid for $target in slot $slot_num_disp. Active: $active_jobs. PIDs: ${!pid_host_map[*]}"
        done # End launch loop

        if [ "$active_jobs" -eq 0 ] && [ "${#queue[@]}" -eq 0 ]; then
            _dbg "No active jobs, empty queue. Done: $done_jobs vs $num_total"
            if [ "$done_jobs" -ge "$num_total" ]; then _dbg "All done, break main."; break;
            else
                _dbg "No active, empty Q, but not all done. Loop terminates."
                echo -e "${CY}Warn: No active jobs & empty Q, but done_jobs ($done_jobs) != num_total ($num_total). Loop ends.${CN}" >&2
                break
            fi
        fi

        if [ "$active_jobs" -gt 0 ]; then
            _dbg "Waiting for any of $active_jobs active job(s)..."
            local comp_pid=""
            local wait_ret=0
            set +e
            if is_bash43_plus; then
                _dbg "Using 'wait -n -p comp_pid'"
                wait -n -p comp_pid 2>/dev/null
                wait_ret=$?
            else
                _dbg "Using 'wait -n' + PID scan fallback"
                wait -n 2>/dev/null
                local wait_n_fb_ret=$?
                wait_ret=$wait_n_fb_ret
                if [ "$wait_n_fb_ret" -ne 127 ]; then # 127 means no children
                    local scans=0
                    _dbg "Fallback scan start. wait_n_ret: $wait_n_fb_ret. PIDs: ${!pid_host_map[*]}"
                    while [ -z "$comp_pid" ] && [ "$scans" -lt 5 ]; do
                        sleep 0.05
                        for p_chk in "${!pid_host_map[@]}"; do
                            if ! kill -0 "$p_chk" 2>/dev/null; then
                                _dbg "Fallback scan found PID $p_chk done (attempt $((scans+1)))."
                                comp_pid="$p_chk"; wait "$comp_pid" 2>/dev/null; wait_ret=$?; break 2
                            fi
                        done
                        scans=$((scans + 1))
                        if [[ -z "$comp_pid" && "$scans" -lt 5 ]]; then _dbg "Fallback scan attempt $scans no PID. Retry..."; fi
                    done
                fi
            fi
            set -e
            _dbg "'wait -n' seq done. wait_ret: $wait_ret. PID: '$comp_pid'"

            if [ -z "$comp_pid" ]; then
                if [ "$wait_ret" -eq 127 ]; then # 'wait -n' found no children
                    _dbg "'wait -n' no children (ret 127). Check tracked PIDs: ${!pid_host_map[*]}"
                    if [ "${#pid_host_map[@]}" -gt 0 ]; then
                        for p_chk127 in "${!pid_host_map[@]}"; do
                            _dbg "Ret 127 sweep: Check PID $p_chk127 (${pid_host_map[$p_chk127]})."
                            if ! kill -0 "$p_chk127" 2>/dev/null; then # Really gone
                                wait "$p_chk127" 2>/dev/null; local final_ret127=$?
                                comp_pid="$p_chk127"; wait_ret=$final_ret127
                                _dbg "Ret 127 sweep: PID $comp_pid done (ret $wait_ret)."
                                break
                            fi
                        done
                    fi
                    if [ -z "$comp_pid" ]; then # Still no PID found after sweep
                         _dbg "Ret 127 sweep: No tracked PIDs found defunct. Assuming active jobs empty if map is empty."
                         if [ "${#pid_host_map[@]}" -eq 0 ]; then active_jobs=0; fi
                    fi
                else # Some child exited, but we couldn't ID it from our list
                    echo -e "${CR}ERR/WARN: Child exited (wait ret $wait_ret), but PID NOT ID'd. Slot freed, output missed.${CN}" >&2
                    if [ "$active_jobs" -gt 0 ]; then
                        active_jobs=$((active_jobs - 1))
                        _dbg "Tentatively decremented active_jobs to $active_jobs (un-ID'd completion)."
                    fi
                fi

                if [ -z "$comp_pid" ]; then # Still no ID
                    if [ "$done_jobs" -ge "$num_total" ] || ([ "$active_jobs" -eq 0 ] && [ "${#queue[@]}" -eq 0 ]); then
                        _dbg "Break main (PID un-ID'd, but term conditions met). Active: $active_jobs, Q: ${#queue[@]}, Done: $done_jobs/$num_total"
                        break
                    fi
                    _dbg "PID not ID'd, sleep 0.1s, continue. Active: $active_jobs, Done: $done_jobs"
                    sleep 0.1; continue
                fi
            fi # End if [ -z "$comp_pid" ] (initial check)

            # --- Process identified completed_pid ---
            local h_for_pid="${pid_host_map["$comp_pid"]}"
            local out_f="${pid_out_map["$comp_pid"]}"
            local err_f="${pid_err_map["$comp_pid"]}"
            local start_t_pid="${pid_start_map["$comp_pid"]}"
            local slot_freed_num="${pid_slot_map["$comp_pid"]}" # 1-based

            _dbg "Process PID: $comp_pid for host: '$h_for_pid' from slot $slot_freed_num. Exit: $wait_ret"

            if [ -z "$h_for_pid" ]; then
                echo -e "${CR}CRITICAL ERR: PID $comp_pid has no host map! Status lost.${CN}" >&2
                if [ "$active_jobs" -gt 0 ]; then active_jobs=$((active_jobs - 1)); fi
            else
                local end_t; end_t=$(date +%s)
                local eff_start_t=${start_t_pid:-$end_t}
                local dur_s=$((end_t - eff_start_t))

                if [ "$active_jobs" -gt 0 ]; then active_jobs=$((active_jobs - 1)); fi
                done_jobs=$((done_jobs + 1))

                local prog_ind="${CM}[${done_jobs}/${num_total} Time: ${dur_s}s]${CN}"
                echo # Blank line
                if [ "$wait_ret" -eq 0 ]; then
                    echo -e "${CG}OK:${CN} ${CB}${h_for_pid}${CN} (PID $comp_pid) ${prog_ind}"
                    ok_cnt=$((ok_cnt + 1))
                else
                    if [ "$wait_ret" -eq 255 ]; then # SSH specific error
                        echo -e "${CR}SSH_ERR:${CN} ${CB}${h_for_pid}${CN} (PID $comp_pid, Exit 255) ${prog_ind}" >&2
                    else
                        echo -e "${CR}FAIL:${CN} ${CB}${h_for_pid}${CN} (PID $comp_pid, Remote Exit $wait_ret) ${prog_ind}" >&2
                    fi
                    fail_cnt=$((fail_cnt + 1))
                fi

                echo -e "${CC}## Out: ${CB}${h_for_pid}${CN} ##${CN}"
                if [ -f "$out_f" ] && [ -s "$out_f" ]; then cat "$out_f"; else echo "[No stdout]"; fi
                if [ -f "$err_f" ] && [ -s "$err_f" ]; then
                    echo -e "${CY}## Err: ${CB}${h_for_pid}${CN} ##${CN}" >&2
                    cat "$err_f" >&2
                fi
                echo -e "${CC}## End ${CB}${h_for_pid}${CN} ##${CN}"
            fi # End if [ -z "$h_for_pid" ]

            _dbg "Unset PID $comp_pid maps. Free slot $slot_freed_num."
            if [[ -n "$slot_freed_num" ]]; then
                slot_pids[$((slot_freed_num - 1))]="" # Mark slot free (0-based index)
            else
                 _dbg "Warn: No slot num for PID $comp_pid to free."
            fi
            unset pid_host_map["$comp_pid"] pid_out_map["$comp_pid"] pid_err_map["$comp_pid"] pid_start_map["$comp_pid"] pid_slot_map["$comp_pid"]

        elif [ "${#queue[@]}" -eq 0 ] && [ "$active_jobs" -eq 0 ]; then # No active jobs, queue empty
            _dbg "No active jobs, queue empty. Break main loop."
            break
        fi # End of if [ "$active_jobs" -gt 0 ] (wait block)
    done # End of while [ "$done_jobs" -lt "$num_total" ]

    _dbg "Exited main loop. Done: $done_jobs. Active: $active_jobs. Queue: ${#queue[@]}. PIDs: ${!pid_host_map[*]}"

    if [ "${#pid_host_map[@]}" -gt 0 ]; then
        echo -e "${CY}Wait for final ${#pid_host_map[@]} straggler PIDs: ${!pid_host_map[*]}...${CN}" >&2
        for strag_pid in "${!pid_host_map[@]}"; do
            _dbg "Wait straggler $strag_pid (${pid_host_map["$strag_pid"]})"
            wait "$strag_pid" 2>/dev/null || true
        done
    fi

    echo "--------------------------------------------------"
    echo -e "${CC}Summary:${CN}"
    echo -e "  ${CG}OK:   $ok_cnt${CN}"
    echo -e "  ${CR}Fail: $fail_cnt${CN}"
    echo -e "  Done: $done_jobs (Target: $num_total)"
    echo "--------------------------------------------------"
    if [ "$fail_cnt" -gt 0 ] || [ "$done_jobs" -lt "$num_total" ]; then return 1; else return 0; fi
}

# --- Main Script ---
main() {
    local sudo_prefix=""
    if [[ "${1:-}" == "--sudo" || "${1:-}" == "-s" ]]; then
        sudo_prefix="sudo "
        shift # Consume the --sudo or -s flag
        _dbg "Sudo mode enabled."
    fi

    local specs_arg=""
    local ex_mode="" # "pipe_script", "list_hosts", "cmd"
    local task_str=""

    if ! [ -t 0 ]; then # Input is piped or redirected
        ex_mode="pipe_script"
        if [ $# -eq 0 ]; then
            echo -e "${CR}Err: No host specs for piped/redirected script.${CN}" >&2
            print_usage; exit 1
        fi
        specs_arg="$1"; shift
        local scr_build=""
        local line
        while IFS= read -r line; do scr_build+="$line"$'\n'; done
        if [ -n "$scr_build" ]; then task_str="${scr_build%$'\n'}"; else task_str=""; fi

        if [ -z "$task_str" ]; then
            echo -e "${CR}Err: Piped/redirected input empty.${CN}" >&2; exit 1
        fi
        if [ $# -gt 0 ]; then
            echo -e "${CY}Warn: Args '$*' ignored with piped/redirected script.${CN}" >&2
        fi
    elif [ $# -eq 0 ]; then # ./xrun (or ./xrun --sudo)
        ex_mode="list_hosts"; specs_arg="@[*]"
    elif [ $# -eq 1 ]; then # ./xrun <host_spec> (or ./xrun --sudo <host_spec>)
        ex_mode="list_hosts"; specs_arg="$1"
    else # ./xrun <host_spec> cmd args... (or ./xrun --sudo <host_spec> cmd args...)
        ex_mode="cmd"; specs_arg="$1"; shift; task_str="$*"
        if [ -z "$task_str" ]; then
            echo -e "${CR}Err: No command after host specs.${CN}" >&2
            print_usage; exit 1
        fi
    fi

    local targets_arr=()
    mapfile -t targets_arr < <(parse_specs "$specs_arg" "$ex_mode") # Pass ex_mode for context

    if [ "$ex_mode" = "list_hosts" ]; then
        if [ ${#targets_arr[@]} -gt 0 ]; then printf '%s\n' "${targets_arr[@]}"; fi
        exit 0
    fi

    # Execution modes from here
    echo -e "${CC}Resolve hosts for spec: '$specs_arg'...${CN}"
    if [ ${#targets_arr[@]} -eq 0 ]; then
        echo -e "${CR}Err: No hosts matched spec '$specs_arg' for exec.${CN}" >&2
        exit 1
    fi

    mkdir -p "$SESS_DIR_ROOT"
    SESS_TMP_DIR=$(mktemp -d "${SESS_DIR_ROOT}/xrun_sess.XXXXXX")
    # shellcheck disable=SC2064
    trap 'echo -e "${CY}Cleanup $SESS_TMP_DIR...${CN}"; rm -rf "$SESS_TMP_DIR"' EXIT TERM INT
    echo -e "${CC}Temp files for session: $SESS_TMP_DIR${CN}"

    local final_task="$task_str"
    if [ "$ex_mode" = "cmd" ]; then # Auto --color for ls/grep if not specified
        local cmd_parts=()
        IFS=' ' read -r -a cmd_parts <<< "$task_str"
        if [ ${#cmd_parts[@]} -gt 0 ]; then
            local cmd_base_raw="${cmd_parts[0]}"
            local cmd_base; cmd_base=$(basename "$cmd_base_raw")
            local has_color_opt=false
            for part in "${cmd_parts[@]}"; do
                if [[ "$part" == --color* ]]; then has_color_opt=true; break; fi
            done

            if [[ ( "$cmd_base" == "ls" || "$cmd_base" == "grep" ) && "$has_color_opt" == false ]]; then
                local first_w="${cmd_parts[0]}"
                local rest_cmd=""
                if [[ ${#cmd_parts[@]} -gt 1 ]]; then
                    local rest_cand="${task_str#"$first_w"}"
                    while [[ "${rest_cand::1}" == ' ' ]]; do rest_cand="${rest_cand#?}"; done
                    rest_cmd="$rest_cand"
                fi
                if [[ -n "$rest_cmd" ]]; then final_task="$first_w --color=always $rest_cmd";
                else final_task="$first_w --color=always"; fi

                if [[ "$final_task" != "$task_str" ]]; then
                    echo -e "${CC}Info: Mod cmd for '$cmd_base' to: '$final_task'${CN}"
                fi
            fi
        fi
    fi

    echo -e "${CC}Found ${#targets_arr[@]} target(s). Strategy: $XRUN_EXEC_STRAT.${CN}"
    if [[ -n "$sudo_prefix" ]]; then
        echo -e "${CY}Executing with sudo.${CN}"
    fi


    local final_ret=0
    if [[ "$XRUN_EXEC_STRAT" == "controlled_parallel" ]]; then
        exec_parallel targets_arr "$ex_mode" "$final_task" "$sudo_prefix"
        final_ret=$?
    else
        echo -e "${CR}Err: Invalid XRUN_EXEC_STRAT: '$XRUN_EXEC_STRAT'. Only 'controlled_parallel' is enabled.${CN}" >&2
        exit 1
    fi

    echo -e "${CG}xrun done.${CN}"
    exit "$final_ret"
}

# --- Call Main ---
main "$@"
